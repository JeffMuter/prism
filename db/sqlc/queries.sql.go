// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const connectUserToLocation = `-- name: ConnectUserToLocation :one
INSERT INTO
  users_locations (user_id, location_id)
VALUES
  (?, ?) RETURNING id
`

type ConnectUserToLocationParams struct {
	UserID     int64
	LocationID int64
}

func (q *Queries) ConnectUserToLocation(ctx context.Context, arg ConnectUserToLocationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, connectUserToLocation, arg.UserID, arg.LocationID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createEgg = `-- name: CreateEgg :exec
INSERT INTO
  eggs (users_locations_id, discovery_time)
VALUES
  (?, ?)
`

type CreateEggParams struct {
	UsersLocationsID int64
	DiscoveryTime    sql.NullTime
}

// Egg queries
func (q *Queries) CreateEgg(ctx context.Context, arg CreateEggParams) error {
	_, err := q.db.ExecContext(ctx, createEgg, arg.UsersLocationsID, arg.DiscoveryTime)
	return err
}

const createHome = `-- name: CreateHome :exec
INSERT INTO
  homes (user_location_id, name)
VALUES
  (?, ?)
`

type CreateHomeParams struct {
	UserLocationID int64
	Name           string
}

func (q *Queries) CreateHome(ctx context.Context, arg CreateHomeParams) error {
	_, err := q.db.ExecContext(ctx, createHome, arg.UserLocationID, arg.Name)
	return err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO
  locations (
    default_accessible,
    latitude,
    longitude,
    name,
    description,
    art,
    location_type_id,
    is_user_created
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type CreateLocationParams struct {
	DefaultAccessible bool
	Latitude          float64
	Longitude         float64
	Name              string
	Description       string
	Art               string
	LocationTypeID    int64
	IsUserCreated     bool
}

// Location queries
func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createLocation,
		arg.DefaultAccessible,
		arg.Latitude,
		arg.Longitude,
		arg.Name,
		arg.Description,
		arg.Art,
		arg.LocationTypeID,
		arg.IsUserCreated,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createLocationResource = `-- name: CreateLocationResource :exec
INSERT INTO
  locations_resources (location_id, resource_id, last_updated, quantity)
VALUES
  (?, ?, ?, ?)
`

type CreateLocationResourceParams struct {
	LocationID  int64
	ResourceID  int64
	LastUpdated sql.NullTime
	Quantity    sql.NullInt64
}

func (q *Queries) CreateLocationResource(ctx context.Context, arg CreateLocationResourceParams) error {
	_, err := q.db.ExecContext(ctx, createLocationResource,
		arg.LocationID,
		arg.ResourceID,
		arg.LastUpdated,
		arg.Quantity,
	)
	return err
}

const createUserLocation = `-- name: CreateUserLocation :one
INSERT INTO
  users_locations (user_id, location_id, name)
VALUES
  (?, ?, ?) RETURNING id
`

type CreateUserLocationParams struct {
	UserID     int64
	LocationID int64
	Name       sql.NullString
}

func (q *Queries) CreateUserLocation(ctx context.Context, arg CreateUserLocationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUserLocation, arg.UserID, arg.LocationID, arg.Name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createWorker = `-- name: CreateWorker :one
INSERT INTO
  workers (
    name,
    user_locations_id,
    religion,
    strength,
    intelligence,
    speed,
    faith,
    luck,
    loyalty,
    charisma
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type CreateWorkerParams struct {
	Name            string
	UserLocationsID int64
	Religion        sql.NullString
	Strength        int64
	Intelligence    int64
	Speed           int64
	Faith           int64
	Luck            int64
	Loyalty         int64
	Charisma        int64
}

func (q *Queries) CreateWorker(ctx context.Context, arg CreateWorkerParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createWorker,
		arg.Name,
		arg.UserLocationsID,
		arg.Religion,
		arg.Strength,
		arg.Intelligence,
		arg.Speed,
		arg.Faith,
		arg.Luck,
		arg.Loyalty,
		arg.Charisma,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createWorkerTask = `-- name: CreateWorkerTask :exec
INSERT INTO
  workers_tasks (
    task_type_id,
    location_id,
    worker_id,
    start_time,
    start_longitude,
    start_latitude,
    end_longitude,
    end_latitude,
    is_ongoing
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateWorkerTaskParams struct {
	TaskTypeID     int64
	LocationID     int64
	WorkerID       int64
	StartTime      time.Time
	StartLongitude float64
	StartLatitude  float64
	EndLongitude   float64
	EndLatitude    float64
	IsOngoing      sql.NullBool
}

// Tasks queries
func (q *Queries) CreateWorkerTask(ctx context.Context, arg CreateWorkerTaskParams) error {
	_, err := q.db.ExecContext(ctx, createWorkerTask,
		arg.TaskTypeID,
		arg.LocationID,
		arg.WorkerID,
		arg.StartTime,
		arg.StartLongitude,
		arg.StartLatitude,
		arg.EndLongitude,
		arg.EndLatitude,
		arg.IsOngoing,
	)
	return err
}

const createWorkerTaskDefaultResting = `-- name: CreateWorkerTaskDefaultResting :exec
INSERT INTO
  workers_tasks (task_type_id, location_id, worker_id, start_time)
VALUES
  (?, ?, ?, ?)
`

type CreateWorkerTaskDefaultRestingParams struct {
	TaskTypeID int64
	LocationID int64
	WorkerID   int64
	StartTime  time.Time
}

func (q *Queries) CreateWorkerTaskDefaultResting(ctx context.Context, arg CreateWorkerTaskDefaultRestingParams) error {
	_, err := q.db.ExecContext(ctx, createWorkerTaskDefaultResting,
		arg.TaskTypeID,
		arg.LocationID,
		arg.WorkerID,
		arg.StartTime,
	)
	return err
}

const decrementWorkerCount = `-- name: DecrementWorkerCount :exec
UPDATE users_locations
SET
  worker_count = worker_count - 1
WHERE
  id = ?
`

func (q *Queries) DecrementWorkerCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, decrementWorkerCount, id)
	return err
}

const endWorkerTask = `-- name: EndWorkerTask :exec
UPDATE workers_tasks
SET
  is_ongoing = false,
  end_time = ?
WHERE
  worker_id = ?
`

type EndWorkerTaskParams struct {
	EndTime  sql.NullTime
	WorkerID int64
}

func (q *Queries) EndWorkerTask(ctx context.Context, arg EndWorkerTaskParams) error {
	_, err := q.db.ExecContext(ctx, endWorkerTask, arg.EndTime, arg.WorkerID)
	return err
}

const getAvailableEggsForUser = `-- name: GetAvailableEggsForUser :many
SELECT
  e.id,
  ul.name
FROM
  eggs e
  JOIN users_locations ul ON ul.id = e.users_locations_id
  JOIN users u ON u.id = ul.user_id
  JOIN locations l ON ul.location_id = l.id
WHERE
  u.id = ?
  AND e.worker_id IS NULL
`

type GetAvailableEggsForUserRow struct {
	ID   int64
	Name sql.NullString
}

func (q *Queries) GetAvailableEggsForUser(ctx context.Context, id int64) ([]GetAvailableEggsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableEggsForUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableEggsForUserRow
	for rows.Next() {
		var i GetAvailableEggsForUserRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEggUserLocationId = `-- name: GetEggUserLocationId :one
SELECT
  users_locations_id
FROM
  eggs
WHERE
  id = ?
`

func (q *Queries) GetEggUserLocationId(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEggUserLocationId, id)
	var users_locations_id int64
	err := row.Scan(&users_locations_id)
	return users_locations_id, err
}

const getLocationById = `-- name: GetLocationById :one
SELECT
  l.id,
  ul.id,
  l.location_type_id,
  l.latitude,
  l.longitude,
  ul.name,
  l.description,
  l.art
FROM
  locations l
  JOIN users_locations ul ON ul.location_id = l.id
WHERE
  l.id = ?
`

type GetLocationByIdRow struct {
	ID             int64
	ID_2           int64
	LocationTypeID int64
	Latitude       float64
	Longitude      float64
	Name           sql.NullString
	Description    string
	Art            string
}

func (q *Queries) GetLocationById(ctx context.Context, id int64) (GetLocationByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getLocationById, id)
	var i GetLocationByIdRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.LocationTypeID,
		&i.Latitude,
		&i.Longitude,
		&i.Name,
		&i.Description,
		&i.Art,
	)
	return i, err
}

const getLocationResources = `-- name: GetLocationResources :many
SELECT
  r.id,
  r.name,
  lr.quantity,
  lr.last_updated
FROM
  locations_resources lr
  JOIN resources r ON r.id = lr.resource_id
WHERE
  lr.location_id = ?
`

type GetLocationResourcesRow struct {
	ID          int64
	Name        string
	Quantity    sql.NullInt64
	LastUpdated sql.NullTime
}

// Resources queries
func (q *Queries) GetLocationResources(ctx context.Context, locationID int64) ([]GetLocationResourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationResources, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationResourcesRow
	for rows.Next() {
		var i GetLocationResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Quantity,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOngoingTaskResourceRates = `-- name: GetOngoingTaskResourceRates :many
SELECT
  r.name,
  ttr.base_rate
FROM
  workers_tasks wt
  JOIN task_types tt ON wt.task_type_id = tt.id
  JOIN task_types_resources ttr ON tt.id = ttr.task_type_id
  JOIN resources r ON ttr.resource_id = r.id
WHERE
  wt.location_id = ?
  AND wt.is_ongoing = TRUE
`

type GetOngoingTaskResourceRatesRow struct {
	Name     string
	BaseRate float64
}

func (q *Queries) GetOngoingTaskResourceRates(ctx context.Context, locationID int64) ([]GetOngoingTaskResourceRatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOngoingTaskResourceRates, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOngoingTaskResourceRatesRow
	for rows.Next() {
		var i GetOngoingTaskResourceRatesRow
		if err := rows.Scan(&i.Name, &i.BaseRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOngoingTasksByLocation = `-- name: GetOngoingTasksByLocation :many
SELECT
  wt.id,
  w.name,
  tt.name,
  wt.start_time
FROM
  workers_tasks wt
  RIGHT JOIN task_types tt ON wt.task_type_id = tt.id
  RIGHT JOIN workers w ON wt.worker_id = w.id
WHERE
  wt.location_id = ?
  AND wt.end_time IS NULL
`

type GetOngoingTasksByLocationRow struct {
	ID        sql.NullInt64
	Name      string
	Name_2    string
	StartTime sql.NullTime
}

func (q *Queries) GetOngoingTasksByLocation(ctx context.Context, locationID int64) ([]GetOngoingTasksByLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, getOngoingTasksByLocation, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOngoingTasksByLocationRow
	for rows.Next() {
		var i GetOngoingTasksByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Name_2,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceIdByName = `-- name: GetResourceIdByName :one
SELECT
  id
FROM
  resources
WHERE
  name = ?
`

func (q *Queries) GetResourceIdByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getResourceIdByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTaskTypes = `-- name: GetTaskTypes :many
SELECT
  name
FROM
  task_types
`

func (q *Queries) GetTaskTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskTypesForLocation = `-- name: GetTaskTypesForLocation :many
SELECT
  tt.id,
  tt.name
FROM
  locations l
  JOIN location_types_tasks ltt ON l.location_type_id = ltt.location_type_id
  JOIN task_types tt ON ltt.task_type_id = tt.id
WHERE
  l.id = ?
`

func (q *Queries) GetTaskTypesForLocation(ctx context.Context, id int64) ([]TaskType, error) {
	rows, err := q.db.QueryContext(ctx, getTaskTypesForLocation, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskType
	for rows.Next() {
		var i TaskType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskTypesForLocationTypeId = `-- name: GetTaskTypesForLocationTypeId :many
SELECT
  tt.name
FROM
  task_types tt
  JOIN location_types_tasks ltt ON tt.id = ltt.task_type_id
  JOIN location_types lt ON ltt.location_type_id = lt.id
WHERE
  lt.id = ?
`

func (q *Queries) GetTaskTypesForLocationTypeId(ctx context.Context, id int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskTypesForLocationTypeId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnconnectedLocations = `-- name: GetUnconnectedLocations :many
SELECT
  l.id,
  ul.name,
  l.latitude,
  l.longitude
FROM
  locations l
  LEFT JOIN users_locations ul ON l.id = ul.location_id
  AND ul.user_id = ?
WHERE
  ul.user_id IS NULL
`

type GetUnconnectedLocationsRow struct {
	ID        int64
	Name      sql.NullString
	Latitude  float64
	Longitude float64
}

func (q *Queries) GetUnconnectedLocations(ctx context.Context, userID int64) ([]GetUnconnectedLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnconnectedLocations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnconnectedLocationsRow
	for rows.Next() {
		var i GetUnconnectedLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id,
  username,
  email,
  password
FROM
  users
WHERE
  email = ?
`

type GetUserByEmailRow struct {
	ID       int64
	Username string
	Email    string
	Password string
}

// User queries
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUserLocationIdByLocationId = `-- name: GetUserLocationIdByLocationId :one
SELECT
  id
FROM
  users_locations
WHERE
  location_id = ?
`

func (q *Queries) GetUserLocationIdByLocationId(ctx context.Context, locationID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserLocationIdByLocationId, locationID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserLocations = `-- name: GetUserLocations :many
SELECT
  l.id,
  ul.id,
  ul.worker_count,
  l.location_type_id,
  l.latitude,
  l.longitude,
  l.description,
  l.art,
  ul.name,
  lt.name,
  l.is_user_created
FROM
  locations l
  JOIN users_locations ul ON l.id = ul.location_id
  JOIN location_types lt ON l.location_type_id = lt.id
WHERE
  ul.user_id = ?
`

type GetUserLocationsRow struct {
	ID             int64
	ID_2           int64
	WorkerCount    sql.NullInt64
	LocationTypeID int64
	Latitude       float64
	Longitude      float64
	Description    string
	Art            string
	Name           sql.NullString
	Name_2         string
	IsUserCreated  bool
}

func (q *Queries) GetUserLocations(ctx context.Context, userID int64) ([]GetUserLocationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserLocations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserLocationsRow
	for rows.Next() {
		var i GetUserLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ID_2,
			&i.WorkerCount,
			&i.LocationTypeID,
			&i.Latitude,
			&i.Longitude,
			&i.Description,
			&i.Art,
			&i.Name,
			&i.Name_2,
			&i.IsUserCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVisibleLocationsByUser = `-- name: GetVisibleLocationsByUser :many
SELECT
  l.id, default_accessible, location_type_id, longitude, latitude, l.name, description, art, is_user_created, l.created_at, ul.id, user_id, location_id, ul.name, worker_count, ul.created_at
FROM
  locations l
  LEFT JOIN users_locations ul ON l.id = ul.location_id
WHERE
  ul.user_id = ?
  OR l.default_accessible = TRUE
`

type GetVisibleLocationsByUserRow struct {
	ID                int64
	DefaultAccessible bool
	LocationTypeID    int64
	Longitude         float64
	Latitude          float64
	Name              string
	Description       string
	Art               string
	IsUserCreated     bool
	CreatedAt         sql.NullTime
	ID_2              sql.NullInt64
	UserID            sql.NullInt64
	LocationID        sql.NullInt64
	Name_2            sql.NullString
	WorkerCount       sql.NullInt64
	CreatedAt_2       sql.NullTime
}

func (q *Queries) GetVisibleLocationsByUser(ctx context.Context, userID int64) ([]GetVisibleLocationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getVisibleLocationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVisibleLocationsByUserRow
	for rows.Next() {
		var i GetVisibleLocationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.DefaultAccessible,
			&i.LocationTypeID,
			&i.Longitude,
			&i.Latitude,
			&i.Name,
			&i.Description,
			&i.Art,
			&i.IsUserCreated,
			&i.CreatedAt,
			&i.ID_2,
			&i.UserID,
			&i.LocationID,
			&i.Name_2,
			&i.WorkerCount,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkersByLocation = `-- name: GetWorkersByLocation :many
SELECT
  w.id,
  w.name,
  w.religion,
  w.work_status,
  w.injured,
  w.intelligence,
  w.strength,
  w.faith,
  ul.name,
  ul.id,
  ul.user_id,
  ul.location_id,
  tt.name
FROM
  workers w
  JOIN users_locations ul ON w.user_locations_id = ul.id
  RIGHT JOIN workers_tasks wt ON w.id = wt.worker_id
  AND wt.end_time IS NULL
  LEFT JOIN task_types tt ON wt.task_type_id = tt.id
WHERE
  ul.location_id = ?
`

type GetWorkersByLocationRow struct {
	ID           int64
	Name         string
	Religion     sql.NullString
	WorkStatus   sql.NullBool
	Injured      sql.NullBool
	Intelligence int64
	Strength     int64
	Faith        int64
	Name_2       sql.NullString
	ID_2         int64
	UserID       int64
	LocationID   int64
	Name_3       sql.NullString
}

func (q *Queries) GetWorkersByLocation(ctx context.Context, locationID int64) ([]GetWorkersByLocationRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkersByLocation, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkersByLocationRow
	for rows.Next() {
		var i GetWorkersByLocationRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Religion,
			&i.WorkStatus,
			&i.Injured,
			&i.Intelligence,
			&i.Strength,
			&i.Faith,
			&i.Name_2,
			&i.ID_2,
			&i.UserID,
			&i.LocationID,
			&i.Name_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkersByUser = `-- name: GetWorkersByUser :many
SELECT
  w.id,
  w.name,
  w.religion,
  w.work_status,
  w.injured,
  w.intelligence,
  w.strength,
  w.faith,
  ul.name,
  ul.id,
  ul.location_id
FROM
  workers w
  LEFT JOIN users_locations ul ON w.user_locations_id = ul.id
WHERE
  ul.user_id = ?
`

type GetWorkersByUserRow struct {
	ID           int64
	Name         string
	Religion     sql.NullString
	WorkStatus   sql.NullBool
	Injured      sql.NullBool
	Intelligence int64
	Strength     int64
	Faith        int64
	Name_2       sql.NullString
	ID_2         sql.NullInt64
	LocationID   sql.NullInt64
}

// Worker queries
func (q *Queries) GetWorkersByUser(ctx context.Context, userID int64) ([]GetWorkersByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkersByUserRow
	for rows.Next() {
		var i GetWorkersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Religion,
			&i.WorkStatus,
			&i.Injured,
			&i.Intelligence,
			&i.Strength,
			&i.Faith,
			&i.Name_2,
			&i.ID_2,
			&i.LocationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementWorkerCount = `-- name: IncrementWorkerCount :exec
UPDATE users_locations
SET
  worker_count = worker_count + 1
WHERE
  id = ?
`

func (q *Queries) IncrementWorkerCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementWorkerCount, id)
	return err
}

const setLocationTypeToHome = `-- name: SetLocationTypeToHome :exec
UPDATE locations
SET
  location_type_id = 10
WHERE
  id = ?
`

// Home queries
func (q *Queries) SetLocationTypeToHome(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setLocationTypeToHome, id)
	return err
}

const toggleWorkerStatus = `-- name: ToggleWorkerStatus :exec
UPDATE workers
SET
  work_status = NOT work_status
WHERE
  id = ?
`

func (q *Queries) ToggleWorkerStatus(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, toggleWorkerStatus, id)
	return err
}

const updateEggAfterHatch = `-- name: UpdateEggAfterHatch :exec
UPDATE eggs
SET
  hatch_time = ?,
  worker_id = ?
WHERE
  id = ?
`

type UpdateEggAfterHatchParams struct {
	HatchTime sql.NullTime
	WorkerID  sql.NullInt64
	ID        int64
}

func (q *Queries) UpdateEggAfterHatch(ctx context.Context, arg UpdateEggAfterHatchParams) error {
	_, err := q.db.ExecContext(ctx, updateEggAfterHatch, arg.HatchTime, arg.WorkerID, arg.ID)
	return err
}

const updateLocationResource = `-- name: UpdateLocationResource :exec
UPDATE locations_resources
SET
  last_updated = ?,
  quantity = ?
WHERE
  location_id = ?
  AND resource_id = ?
`

type UpdateLocationResourceParams struct {
	LastUpdated sql.NullTime
	Quantity    sql.NullInt64
	LocationID  int64
	ResourceID  int64
}

func (q *Queries) UpdateLocationResource(ctx context.Context, arg UpdateLocationResourceParams) error {
	_, err := q.db.ExecContext(ctx, updateLocationResource,
		arg.LastUpdated,
		arg.Quantity,
		arg.LocationID,
		arg.ResourceID,
	)
	return err
}

const updateUserLocationName = `-- name: UpdateUserLocationName :exec
UPDATE users_locations
SET
  name = ?
WHERE
  location_id = ?
`

type UpdateUserLocationNameParams struct {
	Name       sql.NullString
	LocationID int64
}

func (q *Queries) UpdateUserLocationName(ctx context.Context, arg UpdateUserLocationNameParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLocationName, arg.Name, arg.LocationID)
	return err
}

const updateWorkerLocation = `-- name: UpdateWorkerLocation :exec
UPDATE workers
SET
  user_locations_id = ?
WHERE
  id = ?
`

type UpdateWorkerLocationParams struct {
	UserLocationsID int64
	ID              int64
}

func (q *Queries) UpdateWorkerLocation(ctx context.Context, arg UpdateWorkerLocationParams) error {
	_, err := q.db.ExecContext(ctx, updateWorkerLocation, arg.UserLocationsID, arg.ID)
	return err
}
