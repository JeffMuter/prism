// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getVisibleLocationsByUser = `-- name: GetVisibleLocationsByUser :many
SELECT l.id, default_accessible, location_type_id, longitude, latitude, l.name, description, art, is_user_created, l.created_at, ul.id, user_id, location_id, ul.name, worker_count, ul.created_at FROM locations l LEFT JOIN users_locations ul ON l.id = ul.location_id WHERE ul.user_id = ? OR l.default_accessible = TRUE
`

type GetVisibleLocationsByUserRow struct {
	ID                int64
	DefaultAccessible sql.NullBool
	LocationTypeID    int64
	Longitude         float64
	Latitude          float64
	Name              sql.NullString
	Description       sql.NullString
	Art               sql.NullString
	IsUserCreated     sql.NullBool
	CreatedAt         sql.NullTime
	ID_2              sql.NullInt64
	UserID            sql.NullInt64
	LocationID        sql.NullInt64
	Name_2            sql.NullString
	WorkerCount       sql.NullInt64
	CreatedAt_2       sql.NullTime
}

func (q *Queries) GetVisibleLocationsByUser(ctx context.Context, userID int64) ([]GetVisibleLocationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getVisibleLocationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVisibleLocationsByUserRow
	for rows.Next() {
		var i GetVisibleLocationsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.DefaultAccessible,
			&i.LocationTypeID,
			&i.Longitude,
			&i.Latitude,
			&i.Name,
			&i.Description,
			&i.Art,
			&i.IsUserCreated,
			&i.CreatedAt,
			&i.ID_2,
			&i.UserID,
			&i.LocationID,
			&i.Name_2,
			&i.WorkerCount,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
